# CLAUDE.md

## 🚨 AI エージェント向け必読事項

### 読み込み順序
このドキュメントには、プロジェクトのすべてのルールが記載されています。**上から下へ、順番にすべて読んでください。**

### 目次
- [重要: 基本原則](#重要-基本原則)
- [開発コマンド](#開発コマンド)
- [アーキテクチャ](#アーキテクチャ)
- [shadcn/ui 設定](#shadcnui-設定)
- [詳細ガイドライン](#詳細ガイドライン)
  - [コンポーネント分離・作成ガイド](#コンポーネント分離作成ガイド)
  - [命名規則](#命名規則)
  - [Storybook ガイドライン](#storybook-ガイドライン)
  - [テストガイドライン](#テストガイドライン)

---

## 重要: 基本原則

### 1. 日本語コミュニケーション

Claude Code は日本語でコミュニケーションを行う必要があります。すべてのコミットメッセージ、コメント、エラーメッセージ、ユーザーとのやり取りは日本語で行ってください。

### 2. 事前承認要件

**重要**: ファイルの作成、編集、削除を行う前に、必ず以下を報告し、明示的なユーザー承認を得てください：

- 対象ファイルのリスト
- 実行する変更の詳細説明
- 影響範囲の説明

### 3. 決定権限の原則

- **最終決定権限は常にユーザーにある**
- AI は勝手に代替アプローチや回避策を選択してはならない
- 不明な点がある場合は常に質問し、推測で進めてはならない

### 4. CLAUDE.md コンプライアンス確認

作業を開始する前に、このドキュメントの関連ルールとの適合性を確認し、それをユーザーに報告してください。

### 5. 標準ワークフロー

すべてのタスクに対して以下の手順に従ってください：

```yaml
ステップ 1: タスク理解
  - ユーザー要件を明確に理解する
  - 不明な点があれば質問する
  - 期待される成果物を確認する

ステップ 2: 計画立案
  - 詳細な実行計画を作成する
  - 影響を受けるファイルとシステムを特定する
  - リスクと考慮事項を評価する

ステップ 3: 事前報告
  - 計画をユーザーに報告する
  - 明示的な承認を得る
  - 承認なしに実行してはならない

ステップ 4: 実行
  - 計画に従って実行する
  - 予期しない状況を即座に報告する
  - 独断で決定を下してはならない

ステップ 5: 完了報告
  - 実行結果を詳細に報告する
  - 変更の確認を求める
  - 次のアクションを確認する
```

### 6. lefthook とコード品質の遵守

**重要**: lefthook は品質保証の重要な仕組みです：

- **絶対に lefthook を無視してはならない** - `LEFTHOOK=0`の使用は禁止
- lefthook が修正する内容は、コード品質向上のための正しい変更
- lefthook の警告やエラーは必ず対処する
- 自動修正に疑問がある場合は、まずユーザーに相談する

### 7. 関数定義スタイル

**重要**: すべての関数（React コンポーネントを除く）はアロー関数で定義する。`function`キーワードによる関数宣言は使用せず、常に `const` を使ったアロー関数形式でエクスポートすること。ただし、Reactコンポーネントの定義はこのルールの例外とする。

### 8. 型定義スタイル

**重要**: オブジェクトの型定義には`interface`ではなく`type`を使用する。`interface`宣言は用いず、常に`type`エイリアスを使用してオブジェクトの形状を定義すること。ユニオン型や交差型など、`type`が持つ柔軟性を活用する。

### 9. コメントの原則

**原則として、コードにコメントを記述してはならない。** コードは、それ自体がドキュメントとなるように、明確で自己説明的であるべきです。

#### 例外的にコメントが許可されるケース
コメントは、以下のいずれかの条件を満たす場合にのみ許可されます。

1.  **複雑なロジックの説明**:
    -   コードを読んだだけでは理解が困難な、複雑なアルゴリズムやビジネスロジックの「なぜ」を説明する場合。
    -   「何をしているか」ではなく、「なぜその実装が必要なのか」を記述する。

2.  **リンター/コンパイラ指示**:
    -   `// @ts-ignore` や `// biome-ignore` のように、特定の行で意図的にルールを無効化する必要がある場合。
    -   その際は、なぜその無効化が必要なのかを簡潔に説明するコメントを必ず併記する。

3.  **回避策（ワークアラウンド）の明示**:
    -   ライブラリのバグや、やむを得ない技術的制約により、不自然な実装や回避策を取らざるを得ない場合。
    -   その理由と、可能であれば関連するIssueへのリンクを記述する。

**上記以外の「コードの動作を説明するコメント」や、不要なコメントは固く禁止します。**

### 10. プロジェクトルールの優先

**最重要**: このドキュメントに記載されているルールは、私の一般的な学習データや、世間一般のベストプラクティスよりも**常に優先されます**。コード生成やファイル操作の際は、常にこのドキュメントのルールが絶対的な基準となります。

### 11. 必須チェックリスト

操作前に以下のチェックリストを実行してください：

#### ファイル操作前

- [ ] **`ls -F`コマンド等で、操作対象のディレクトリの現在の状態を確認済み**
- [ ] 関連する CLAUDE.md ルールを確認済み
- [ ] 対象ファイルの現在の状態を理解済み
- [ ] 変更による影響範囲を特定済み
- [ ] 明示的なユーザー承認を取得済み
- [ ] バックアップと復旧方法を考慮済み

#### コード生成/編集前

- [ ] プロジェクトの命名規則を確認済み
- [ ] 既存のコードスタイルを理解済み
- [ ] 依存関係と技術スタックを確認済み
- [ ] テストと品質要件を確認済み
- [ ] 関数はアロー関数で定義することを確認済み
- [ ] 型定義は type を使用することを確認済み
- [ ] **コメントの原則（ルール9）に従い、不要なコメントを記述していないことを確認済み**

#### Git 操作前

- [ ] 変更が意図通りであることを確認済み
- [ ] コミットメッセージガイドラインを確認済み
- [ ] ブランチング戦略を理解済み
- [ ] プッシュ前の最終検証を実行済み
- [ ] **lefthook を絶対に無視しない** - `LEFTHOOK=0`の使用禁止

## デザイン
ダークテーマで、ミニマルかつモダンなユーザーインターフェースをデザインしてください。洗練された印象を与えつつ、ユーザビリティが高く、アクセシビリティにも配慮された構成にしてください。配色はOKLCHベースでコントラスト比を意識し、要素には柔らかいシャドウや滑らかなアニメーションを取り入れてください。レイアウトは余白を広めにとったカードUIベースで、現代的なWebアプリのような見た目を目指してください。

## 開発コマンド

### 基本コマンド

- `bun run dev` - 開発サーバーを開始（Next.js）
- `bun run build` - 本番アプリケーションをビルド
- `bun run start` - 本番サーバーを開始
- `bun run typecheck` - TypeScript で型チェック

### コード品質コマンド

- `bun run check` - Biome リンターとフォーマッターのチェックを実行
- `bun run check:fix` - Biome で自動修正を実行（安全でない修正を含む）
- `bun run format` - Biome でフォーマットをチェック
- `bun run format:fix` - Biome でコードを自動フォーマット

### テストコマンド

- `bun run test` - Vitest でテストを一度実行して終了（`bun test`の代わりに使用）

### コード解析コマンド

- `similarity-ts .` - コードベース全体で重複する関数と類似コードパターンを検出

### Git フック

- **Pre-commit**: 自動的に `bun run check:fix` を実行し、修正されたファイルをステージ
- **Pre-push**: プッシュ前に `bun run check` と `bun run typecheck` を実行

## アーキテクチャ

### 技術スタック

- **フレームワーク**: Next.js 15 with App Router
- **言語**: TypeScript
- **スタイリング**: Tailwind CSS v4
- **UI コンポーネント**: shadcn/ui with Radix UI primitives
- **コード品質**: Biome for linting and formatting
- **Git hooks**: Lefthook

### プロジェクト構造

```
src/
├── app/                    # Next.js App Router
│   ├── globals.css        # グローバルスタイル
│   ├── layout.tsx         # ルートレイアウト
│   └── page.tsx           # ホームページ
├── components/
│   ├── ui/                # shadcn/ui コンポーネント
│   ├── shared/            # 機能間で再利用可能なコンポーネント
│   └── features/          # 機能固有のコンポーネント
├── lib/                   # グローバルユーティリティ関数
└── hooks/                 # グローバルカスタムフック
```

### コンポーネントアーキテクチャ

- **UI コンポーネント**: `src/components/ui/` に配置 - shadcn/ui コンポーネントのみ
- **共有コンポーネント**: `src/components/shared/` に配置 - 機能間で再利用可能なコンポーネント
- **機能コンポーネント**: `src/components/features/` に配置 - 画面/ページ固有のコンポーネント
- **ユーティリティ関数**: `src/lib/utils.ts` の `cn()` 関数で clsx と tailwind-merge を使用したクラス名マージ
- **インポートエイリアス**: クリーンなインポートのために `@/` プレフィックスを設定

### Package by Feature アーキテクチャ

**核心原則**: 技術タイプではなく機能によって関連するコードをグループ化する。機能固有のロジックは、それを使用するコンポーネントの近くに配置する。

#### ディレクトリ組織ルール

1. **グローバルユーティリティ**: 真にジェネリックな関数は `src/lib/` または `src/hooks/` に配置
2. **機能固有ロジック**: 機能に固有のフック、ユーティリティ、型は機能ディレクトリ内に配置
3. **コロケーション**: 関連するコードは可能な限り使用される場所の近くに配置

#### 例

##### ✅ 正しい機能組織

```
src/components/features/chat-page/
├── ChatPage.tsx                 # メインコンポーネント
├── messageHandlers.ts           # 機能固有ロジック
├── useChatState.ts             # 機能固有フック
├── types.ts                    # 機能固有型
├── chat-header/
│   └── ChatHeader.tsx
├── chat-message/
│   ├── ChatMessage.tsx
│   └── messageUtils.ts         # メッセージ固有ユーティリティ
└── chat-input-area/
    ├── ChatInputArea.tsx
    └── inputValidation.ts      # 入力固有ロジック
```

##### ❌ 間違った組織

```
src/
├── hooks/
│   ├── useChatState.ts         # chat-page 機能にあるべき
│   └── useMessageHandling.ts   # chat-page 機能にあるべき
├── utils/
│   ├── messageHandlers.ts      # chat-page 機能にあるべき
│   └── inputValidation.ts      # chat-input-area にあるべき
└── components/features/chat-page/
    └── ChatPage.tsx            # ロジックから分離されている
```

#### グローバル vs 機能固有のガイドライン

**グローバル位置に配置**（`src/lib/`, `src/hooks/`）:

- 複数の機能で使用されるユーティリティ
- 核心的なアプリケーションロジック
- サードパーティ統合
- 共通型定義

**機能ディレクトリに配置**:

- 機能固有のビジネスロジック
- コンポーネント固有のユーティリティ
- 機能固有のフック
- 機能固有の型
- その機能内でのみ使用されるロジック

### データフローと責務 (Entity / Gateway)

本プロジェクトでは、データの流れと責務を明確にするため、`Entity`と`Gateway`という2つの重要な概念を導入しています。

#### Entity: アプリケーションの「核」となるデータ構造

**役割**:
`Entity`は、アプリケーションで扱う中核的なデータ（例: `User`, `Rule`）の形状と型を定義します。プロジェクト全体で利用されるデータ構造の「信頼できる唯一の情報源（Single Source of Truth）」です。純粋なデータ構造の定義に専念し、ビジネスロジックや副作用（API通信など）は一切含みません。

**作り方**:
1.  `src/entities/{エンティティ名}/index.ts` にファイルを作成します。
2.  `zod`を用いて、データのスキーマ（例: `UserSchema`）を定義します。これにより、型定義だけでなく、実行時のバリデーションも可能になります。
3.  `z.infer`を使って、定義したスキーマからTypeScriptの型（例: `type User = z.infer<typeof UserSchema>;`）を自動的に推論します。
4.  スキーマと型の両方を`export`します。

#### Gateway: 外部世界との「境界」

**役割**:
`Gateway`は、アプリケーションの内部と外部（API、データベース、ローカルストレージなど）との通信を担当する唯一の層です。データが「どこから」「どのように」取得されるかの具体的な実装詳細を隠蔽し、アプリケーションの他の部分がデータソースを意識しなくて済むようにします。

**作り方**:
1.  `src/gateways/{エンティティ名}/index.ts` にファイルを作成します。
2.  関数名は`fetchRuleArray`や`createUser`のように、操作内容が明確にわかるようにします。
3.  戻り値の型は、必ず対応する`Entity`の`Promise`（例: `Promise<Rule[]>`）とします。
4.  **（最重要）** APIなどから取得した生データは、必ず対応する`EntitySchema`を使ってパース（例: `RuleSchema.array().parse(rawData)`)します。これにより、アプリケーション内に流れるデータが、意図した型と構造であることが常に保証されます。
5.  開発環境では、`@/utils`の`isDevelopment`関数を用いて環境を判定し、モックデータを返すように実装します。

## shadcn/ui 設定

### セットアップ

- **スタイル**: New York variant
- **ベースカラー**: Neutral
- **CSS 変数**: 有効
- **RSC**: React Server Components 有効
- **アイコンライブラリ**: Lucide React

### パスエイリアス

- `@/components` → `src/components`
- `@/lib` → `src/lib`
- `@/utils` → `src/lib/utils`
- `@/ui` → `src/components/ui`
- `@/hooks` → `src/hooks`

---
## 詳細ガイドライン

## コンポーネント分離・作成ガイド

## shadcn/ui コンポーネントの活用原則

### 核心原則: 既存コンポーネントの最大活用

新しいfeaturesコンポーネントを作成する前に、必ず以下の確認を行ってください：

1. **既存UIコンポーネントの確認**
   - `src/components/ui/`内のshadcn/uiコンポーネントで実現できないか検討
   - 複数のUIコンポーネントの組み合わせで要件を満たせないか検討

2. **コンポーネント選択の優先順位**
   1. 単一のshadcn/uiコンポーネントで実現可能 → そのまま使用
   2. 複数のshadcn/uiコンポーネントの組み合わせで実現可能 → 組み合わせて使用
   3. 既存コンポーネントのカスタマイズで実現可能 → propsやclassNameで調整
   4. 上記で実現不可能 → 新規カスタムコンポーネントを作成

3. **shadcn/ui活用の利点**
   - アクセシビリティが担保されている
   - ダークモード対応済み
   - 一貫性のあるデザイン
   - メンテナンスコストの削減

### 利用可能なshadcn/uiコンポーネント一覧
- フォーム関連: `form`, `input`, `textarea`, `select`, `checkbox`, `radio-group`, `switch`
- フィードバック: `alert`, `alert-dialog`, `dialog`, `toast`（sonner）
- ナビゲーション: `tabs`, `navigation-menu`, `breadcrumb`, `pagination`
- レイアウト: `card`, `separator`, `accordion`, `collapsible`
- データ表示: `table`, `badge`, `avatar`, `progress`
- その他多数...

## コンポーネント命名規則

### 厳格なルール
1.  **ディレクトリ名**: kebab-case
2.  **TSXファイル名**: PascalCase
3.  **TSファイル名**: camelCase（ユーティリティ関数、ヘルパー、型など）
4.  **コンポーネント名**: PascalCase（ファイル名と完全一致）
5.  **ディレクトリとファイル名の対応**: kebab-caseからPascalCaseへの変換規則に従うこと。
6.  **バレルファイル禁止**: `index.ts`による集約エクスポートは行わず、必ず個別のファイルから直接インポートすること。
7.  **インポートパス**: `@/`エイリアスを使用し、相対パスは使用しないこと。

### 対応規則
- ディレクトリ名とTSXファイル名は、kebab-caseからPascalCaseへの変換規則において一致している必要がある。
- TSXファイル名と、その中で定義され���コンポーネント名は完全に一致させること。
- 上記の規則に合致しないコンポーネントを作成する場合は、新しいディレクトリを作成すること。

### 命名変換テーブル
ディレクトリ名（kebab-case）、TSXファイル名（PascalCase）、TSファイル名（camelCase）、コンポーネント名（PascalCase）は、それぞれ定められた命名規則に従う必要があります。例えば、`video-grid`というディレクトリには`VideoGrid.tsx`というコンポーネントファイルが配置され、その中のコンポーネント名は`VideoGrid`となります。

### インポートスタイル
コンポーネントをインポートする際は、必ずファイルパスを直接指定すること。`index.ts`（バレルファイル）からまとめてインポートする形式は禁止です。

### ディレクトリ構造ガイドライン
コンポーネントは、その役割に応じて`ui/`、`shared/`、`features/`のいずれかのディレクトリに配置します。`ui/`はshadcn/ui由来のコンポーネント、`shared/`は機能横断で再利用��れるコンポーネント、`features/`は特定の機能やページに固有のコンポーネントを格納します。

## Server/Client Components 使い分けルール

### 基本原則: Server Components優先
原則として、すべてのコンポーネントはServer Componentsとして作成し、インタラクティブ性やブラウザAPIへのアクセスなど、明確な理由がある場合にのみClient Componentsを使用します。

### 必須ルール
1.  **page.tsx は必ずServer Component**: ページのルートとなるコンポーネントは、必ずServer Componentとして実装します。
2.  **`'use client'` は最小限**: Client Componentsの使用は、本当に必要なコンポーネントに限定します。
3.  **データフェッチ優先度**: データフェッチは、可能な限りServer Componentsで行います。

### Server Components を使用する場合（デフォルト）
静的なコンテンツ表示、データベースやAPIからのデータ取得、SEOが重要なページ、初期表示速度が求められる場合、またはサーバー側の環境変数にアクセスする必要��ある場合は、Server Componentsを使用します。

### Client Components を使用する場合（必要時のみ）
`useState`や`useEffect`といったReactフックが必要な場合、`localStorage`などのブラウザAPIを使用する場合、`onClick`などのイベントハンドラを実装する場合、またはクライアントサイドでの実行が必須のサードパーティライブラリを使用する場合は、Client Componentsを選択します。

### 判断基準チェックリスト
コンポーネントを作成する際は、まずServer Componentとして実装可能か検討します。ReactフックやブラウザAPI、イベントハンドラが必要になった時点で、初めてClient Componentへの切り替えを検討してください。

### パフォーマンス最適化パターン
ページ全体をClient Componentにするのではなく、静的な部分はServer Componentとして残し、インタラクティブな機能を持つ部分のみを別のClient Componentとして切り出すことで、パフォーマンスを最適化します。

## コンポーネント分離ガイドライン

### 核心原則: 動作の観察可能性
コンポーネントを分離するかの判断は、コードの行数ではなく、「その動作がテスト可能か」を基準に行います。テストを書くためにコンポーネントの責務を明確にする必要がある場合、それが分離のサインです。

### 分離しない場合
コンポーネントの表示内容が、受け取ったpropsの値によって単純に切り替わるだけであれば、分離は不要です。このようなコンポーネントは、Storybookで異なるpropsを与えたストーリーを作成することで、各表示パターンを十分にテストできます。

### 分離する場合
propsから受け取った値を基に、何らかの計算や複雑な条件判定を行い、その結果によって表示を切り替える場合は、分離を検討します。計算ロジックをコンポーネントから抽出し、純粋な関数としてテスト可能にすることが推奨されます。コンポーネント自体は、その計算結果をpropsとして受け取り、表示に専念するようにします。

## 高度なパターン: 内部可視性制御
親コンポーネント側で条件分岐を用いてコンポーネントの表示・非表示を切り替えるのではなく、常にコンポーネントをレンダリングし、`isVisible`のようなpropsを渡してコンポーネント内部で表示を制御します。この方法により、親の持つ状態（フックなど）をモックすることなく、コンポーネントを単体でテストしやすくなります。

## 高度なパターン: 完全ロジック抽出
外部の状態（フックやprops）に依存する複雑な分岐ロジックは、条件判定部分だけでなく、分岐後の処理全体をコンポーネントから別の関数として抽出します。コンポーネントは、その抽出された関数を呼び出すだけのシンプルな役割に徹することで、テストが容易になり、責務が明確になります。

### 高度なパターン: Presenterによる表示ロジックの分離

**核心原則**: コンポーネント内に複雑な表示ロジック（文字列の加工、条件によるテキストの出し分けなど）を直接記述せず、`presenter.ts`ファイルに分離します。

これにより、コンポーネントと表示ロジックの責務を明確に分けます。

#### 各ファイルの役割

-   **`Component.tsx`**:
    -   JSXの構造定義、propsの受け渡し、stateやフックの管理に専念します。
    -   表示に必要な値は、`presenter.ts`からインポートした関数を呼び出して取得します。

-   **`presenter.ts`**:
    -   コンポーネントから渡されたデータ（propsなど）を基に、表示用の文字列や値を生成する**純粋な関数**のみを配置します。
    -   副作用（API通信など）は一切含みません。

#### 作り方

1.  コンポーネントファイル（`.tsx`）と同じ階層に`presenter.ts`を作成します。
2.  表示ロジックを、データを受け取って表示用の値を返す純粋関数として`presenter.ts`に切り出します。
3.  コンポーネントファイルでは、その関数をインポートして使用します。

#### このパターンの利点

-   **責務の分離**: コンポーネントは「どのように表示するか（構造）」に、Presenterは「何を表示するか（内容）」にそれぞれ集中できます。
-   **テストの容易性**: 表示ロジックがUIから完全に独立した純粋関数になるため、非常に簡単に単体テストが書けます。
-   **可読性の向上**: コンポーネント内のJSXから複雑な三項演算子や文字���操作が消え、見通しが良くなります。

## Package by Feature アーキテクチャ
関連するコードは、技術的な分類（例: `hooks`, `utils`）ではなく、機能的なまとまりでグループ化します。機能固有のロジック、フック、型定義などは、���れらを使用するコンポーネントの近くに配置（コロケーション）することで、コードの凝集度を高め、保守性を向上させます。真に汎用的で、複数の機能から利用されるものだけを、`src/lib`や`src/hooks`といったグローバルな場所に配置します。

## 決定フレームワーク
コンポーネントを分離するかどうかは、以下の点を考慮して決定します。
- その動作はpropsで制御できるか？
- 外部の条件によってレンダリングが左右されるか？
- 外部の状態に依存した複雑なロジックを含んでいるか？
- レンダリング前に計算処理が必要か？
- その部分だけで意味のあるテストが書けるか？
- 明確で単一の責任を持っているか？

適切な分離は、テスト可能性、再利用性、保守性を高め、Storybookによるドキュメント化を容易にします。

## コンポーネント作成チェックリスト
コンポーネントを作成する際は、配置場所、命名規則、インポートパスのエイリアス使用、バレルファイルの不使用、`Package by Feature`の原則、Server/Client Componentsの適切な選択など、本ガイドラインに定められたすべてのルールを遵守してください。また、`role`のようなHTMLのARIA属性と競合するprop名は避けてください。

## AIエージェント向け重要な注意事項
コンポーネントの作成やリファクタリングを行う前には、必ずユーザーの承認を得てください。その際、適用する命名規則や正確なファイルパスを含んだ、明確な計画を提示することが求められます。
## 命名規則

## 英語文法規則

**原則**: 自然な英語を使用し、適切な文法規則に従います。

### 基本規則
- **関数**: `getUserById`や`isValid`のように、処理内容を表す動詞で始めます。
- **変数**: `userId`や`isLoading`のように、データの内容を表す名詞を使用します。
- **コンポーネント**: `UserProfile`のように、UIの役割を表す名詞を使用します。
- **イベントハンドラー**: `handleSubmit`のように、`handle` + イベント名で命名します。
- **関数引数**: 2個以上の引数を持つ場合は、個別に渡すのではなくオブジェクト形式で渡します。

### よくある間違いの回避
- 関数名から動詞を省略しないこと。
- 日本語的な発想の直訳（例: `getUserInfo`）ではなく、より自然な英語（例: `getUserInformation`）を選ぶこと。
- 不自然な語順（例: `usersActive`）ではなく、正しい英語の語順（例: `activeUsers`）にすること。

## 省���規則

**原則**: 省略形を避け、完全な英語の単語を使用します。

### 基本規則
- `bg`や`btn`のような安易な省略は避け、`backgroundColor`や`button`のように完全な単語で記述します。
- `id`、`url`、`ref`のような、技術的に広く確立された用語のみ省略が許可されます。

### 頭字語の大文字小文字規則
複合語の中に頭字語（例: URL, API, JWT）が含まれる場合、その頭字語は元のケースを維持します。例えば、`generateURLParameter`のように`URL`はすべて大文字のままにします。`generateUrlParameter`のようにキャメルケースに変換してはいけません。
## Storybook ガイドライン

## ストーリーを書く場合

**核心ルール**: **propsで制御される視覚的な分岐**に対してのみ、新しいストーリーを作成します。視覚的な違いがない場合や、propsで分岐を制御できない場合は、ストーリーを追加するのではなく、コンポーネントの分離方法を再検討する必要があります。

## ストーリー設定

### Metaオブジェクト設定
`meta`オブジェクトの設定は、コンポーネントの指定と、必要に応じた`args`の定義という、最小限の構成を基本とします。`title`や`parameters`といった追加の設定は、特別な要件がない限り省略してください。

### イベントハンドラー設定
`onClick`のようなイベントハンドラーをpropsに持つコンポーネントの場合、`args`プロパティで`fn()`関数を渡すことで、StorybookのUI上でインタラクションを記録できるようにします。

## ストーリー作成の指針

### ストーリーを複数作成する場合
コンポーネントがpropsを通じて複数の視覚的バリエーション（例: `primary`, `secondary`, `disabled`状態など）を持つ場合、そのバリエーションごとにストーリーを作成します。これにより、コンポーネントの各状態を一覧で確認できます。

### 単一ストーリーで十分な場合
コンポーネントにpropsで制御できるような視覚的な分岐が存在しない場合は、そのコンポーネントの基本的な表示を確認するための単一のストーリー（例: `Default`）があれば十分です。

### アンチパターン: 制御できない分岐
コンポーネントが内部に状態（例: `useState`によるローディング状態）を持ち、その状態を外部のpropsから制御できない場合、その状態ごとのストーリーを作成することはできません。これは不適切なコンポーネント設計の兆候であり、内部状態をpropsで制御できるようにコンポーネントをリファクタリング（分離）する必要があります。

## ストーリーの構成
- 意味のある視覚的な状態ごとに1つのストーリーを作成します。
- ストーリー名は、その視覚的な違いが明確にわかるように命名します。
- 関連するバリエーションは、Storybookの階層命名機能を使ってグループ化します。
- 空の状態や長いテキストなど、エッジケースを考慮したストーリーも作成します。

## 非視覚的ストーリーを避ける
**核心原則**: Storybookは視覚的確認のためのツールであり、ロジックテストのツールではありません。

### 回避すべき例
- コンポーネントが何もレンダリングしない状態（例: `isVisible: false`）のストーリー。
- 内部のフックや状態に依存し、外部から制御できないストーリー。
- 見た目が全く同じになる複数のストーリー。

### 代替手段
上記のような非視覚的なロジックや状態は、Storybookではなく、Vitestなどを用いた単体テストやスナップショットテストで検証してください。

## 警告サイン
以下のような状況に遭遇した場合、コンポーネントの分離が不十分である可能性が高いです。
1.  コンポーネントの特定の見た目を再現するストーリーが作れない。
2.  ストーリーを作るために、内部で使われているフックのモックが必要になる。
3.  複数のストーリーが、見た目上まったく同じになる。
4.  コンポーネントの内部状態をテストする必要がある。
5.  何も表示されないストーリーができてしまう。

これらの問題は、ロジックをコンポーネントから抽出し、propsで制御可能な設計にリファクタリングすることで解決できます。
## テストガイドライン

## Vitest のインポート要件
**重要**: Vitestのテスト関数（`describe`, `test`, `expect`など）は、グローバルに利用できません。各テストファイルの先頭で、必ず`vitest`から明示的にインポートする必要があります。

## テストタイトルの日本語化
**重要**: すべてのテストタイトル（`describe`と`test`の第一引数）は、日本語で具体的に記述してください。これにより、コードレビューの効率とテスト内容の可読性が向上します。

テストタイトルには、テスト対象の条件となるprops名や変数名、そしてその具体的な値を明記します。「〜の場合、〜すること」や「〜の時、〜されること」といった形式で、テストの意図が明確に伝わるように記述してください。

## テストを書く場合
**核心ルール**: すべての条件ロジック（`if`文、三項演算子など）に対してテストを作成します。コード内に存在するすべての分岐パスを網羅することが目標です。

## テストの種類と目的

### ロジックテスト（単体テスト）
コンポーネントから抽出された純粋な関数や、propsでは制御できない複雑なビジネスロジックを対象とします。ロジックの正しさを検証することが目的です。テストが困難な場合は、ロジックがコンポーネントに密結合しているサインであり、ロジックを別の関数として抽出するリファクタリングを検討してください。

### コンポーネントテスト
propsによって表示や動作が変化するUIコンポーネントを対象とします。propsの様々な組み合わせに対して、コンポーネントが意図通りにレンダリングされるか、インタラクションが正しく機能するかを検証します。

### スナップショットテスト
HTMLの構造やARIA属性など、アクセシビリティに関わるセマンティックな構造が意図せず変更さ��ていないかを監視するために使用します。スタイリングの変更や動的なコンテンツのテストには不向きであり、それらの目的で使用してはいけません。

## テスト構造ルール

### テストの簡潔性と焦点
**核心ルール**: テストはシンプルに保ち、必須の条件ロジックのみに焦点を当てます。過度なテストや不必要な複雑さは避けてください。

### Arrange-Act-Assert (AAA) パターン
すべてのテストは、**Arrange（準備）**、**Act（実行）**、**Assert（検証）**の3つのステップで構成します。テストの可読性を高めるため、テスト対象の関数を実行した結果を`actual`、期待値を`expected`という変数名で定義することを推奨します。

### テスト構成の規則
1.  **`describe`のネスト禁止**: `describe`ブロックはネストせず、単一レベルでのみ使用します。
2.  **`test()`の使用**: 個別のテストケースには`it()`ではなく`test()`を使用します。
3.  **テストごとに1つの検証**: 1つの`test`ブロックでは、原則と��て1つのことだけを検証します（`expect`は1つ）。複数のプロパティを検証する場合は、オブジェクト比較を用います。
4.  **共通データの共有**: 複数のテストで共通するデータは、`describe`ブロックのスコープで定義します。
5.  **重要な分岐に集中**: 核心的なロジックの分岐に焦点を当て、自明なケースや過度なエッジケースのテストは避けます。
6.  **コメントの削除**: `Arrange`, `Act`, `Assert`のような自明なコメントは記述しません。

## テスト戦略
プロジェクトでは、ロジックテスト、コンポーネントテスト、スナップショットテスト、Storybookを組み合わせ、それぞれの目的に応じて使い分けます。将来的にはE2Eテストの導入も視野に入れます。

## テストカバレッジ目標
ロジック関数は100%、コンポーネントは重要な分岐を網羅し、プロジェクト全体で80%以上のカバレッジを目指します。

## AIエージェント向け重要な注意事項
テストファイルを作成・編集する前には、��ずユーザーの承認を得てください。その際、どのテスト戦略を用い、どのケースをカバーするのかを明確に計画として提示することが求められます。
